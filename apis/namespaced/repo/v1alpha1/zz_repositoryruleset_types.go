/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
	v2 "github.com/crossplane/crossplane-runtime/v2/apis/common/v2"
)

type BranchNamePatternInitParameters struct {

	// (String) How this rule will appear to users.
	// How this rule will appear to users.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Boolean) If true, the rule will fail if the pattern matches.
	// If true, the rule will fail if the pattern matches.
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// (String) The operator to use for matching. Can be one of: starts_with, ends_with, contains, regex.
	// The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// (String) The pattern to match with.
	// The pattern to match with.
	Pattern *string `json:"pattern,omitempty" tf:"pattern,omitempty"`
}

type BranchNamePatternObservation struct {

	// (String) How this rule will appear to users.
	// How this rule will appear to users.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Boolean) If true, the rule will fail if the pattern matches.
	// If true, the rule will fail if the pattern matches.
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// (String) The operator to use for matching. Can be one of: starts_with, ends_with, contains, regex.
	// The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// (String) The pattern to match with.
	// The pattern to match with.
	Pattern *string `json:"pattern,omitempty" tf:"pattern,omitempty"`
}

type BranchNamePatternParameters struct {

	// (String) How this rule will appear to users.
	// How this rule will appear to users.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Boolean) If true, the rule will fail if the pattern matches.
	// If true, the rule will fail if the pattern matches.
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// (String) The operator to use for matching. Can be one of: starts_with, ends_with, contains, regex.
	// The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
	// +kubebuilder:validation:Optional
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// (String) The pattern to match with.
	// The pattern to match with.
	// +kubebuilder:validation:Optional
	Pattern *string `json:"pattern" tf:"pattern,omitempty"`
}

type BypassActorsInitParameters struct {

	// (Number) The ID of the actor that can bypass a ruleset. If actor_type is Integration, actor_id is a GitHub App ID. App ID can be obtained by following instructions from the Get an App API docs
	// The ID of the actor that can bypass a ruleset. When `actor_type` is `OrganizationAdmin`, this should be set to `1`.
	ActorID *int64 `json:"actorId,omitempty" tf:"actor_id,omitempty"`

	// (String) The type of actor that can bypass a ruleset. Can be one of: RepositoryRole, Team, Integration, OrganizationAdmin.
	// The type of actor that can bypass a ruleset. Can be one of: `RepositoryRole`, `Team`, `Integration`, `OrganizationAdmin`.
	ActorType *string `json:"actorType,omitempty" tf:"actor_type,omitempty"`

	// (String) When the specified actor can bypass the ruleset. pull_request means that an actor can only bypass rules on pull requests. Can be one of: always, pull_request.
	// When the specified actor can bypass the ruleset. pull_request means that an actor can only bypass rules on pull requests. Can be one of: `always`, `pull_request`.
	BypassMode *string `json:"bypassMode,omitempty" tf:"bypass_mode,omitempty"`
}

type BypassActorsObservation struct {

	// (Number) The ID of the actor that can bypass a ruleset. If actor_type is Integration, actor_id is a GitHub App ID. App ID can be obtained by following instructions from the Get an App API docs
	// The ID of the actor that can bypass a ruleset. When `actor_type` is `OrganizationAdmin`, this should be set to `1`.
	ActorID *int64 `json:"actorId,omitempty" tf:"actor_id,omitempty"`

	// (String) The type of actor that can bypass a ruleset. Can be one of: RepositoryRole, Team, Integration, OrganizationAdmin.
	// The type of actor that can bypass a ruleset. Can be one of: `RepositoryRole`, `Team`, `Integration`, `OrganizationAdmin`.
	ActorType *string `json:"actorType,omitempty" tf:"actor_type,omitempty"`

	// (String) When the specified actor can bypass the ruleset. pull_request means that an actor can only bypass rules on pull requests. Can be one of: always, pull_request.
	// When the specified actor can bypass the ruleset. pull_request means that an actor can only bypass rules on pull requests. Can be one of: `always`, `pull_request`.
	BypassMode *string `json:"bypassMode,omitempty" tf:"bypass_mode,omitempty"`
}

type BypassActorsParameters struct {

	// (Number) The ID of the actor that can bypass a ruleset. If actor_type is Integration, actor_id is a GitHub App ID. App ID can be obtained by following instructions from the Get an App API docs
	// The ID of the actor that can bypass a ruleset. When `actor_type` is `OrganizationAdmin`, this should be set to `1`.
	// +kubebuilder:validation:Optional
	ActorID *int64 `json:"actorId" tf:"actor_id,omitempty"`

	// (String) The type of actor that can bypass a ruleset. Can be one of: RepositoryRole, Team, Integration, OrganizationAdmin.
	// The type of actor that can bypass a ruleset. Can be one of: `RepositoryRole`, `Team`, `Integration`, `OrganizationAdmin`.
	// +kubebuilder:validation:Optional
	ActorType *string `json:"actorType" tf:"actor_type,omitempty"`

	// (String) When the specified actor can bypass the ruleset. pull_request means that an actor can only bypass rules on pull requests. Can be one of: always, pull_request.
	// When the specified actor can bypass the ruleset. pull_request means that an actor can only bypass rules on pull requests. Can be one of: `always`, `pull_request`.
	// +kubebuilder:validation:Optional
	BypassMode *string `json:"bypassMode" tf:"bypass_mode,omitempty"`
}

type CommitAuthorEmailPatternInitParameters struct {

	// (String) How this rule will appear to users.
	// How this rule will appear to users.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Boolean) If true, the rule will fail if the pattern matches.
	// If true, the rule will fail if the pattern matches.
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// (String) The operator to use for matching. Can be one of: starts_with, ends_with, contains, regex.
	// The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// (String) The pattern to match with.
	// The pattern to match with.
	Pattern *string `json:"pattern,omitempty" tf:"pattern,omitempty"`
}

type CommitAuthorEmailPatternObservation struct {

	// (String) How this rule will appear to users.
	// How this rule will appear to users.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Boolean) If true, the rule will fail if the pattern matches.
	// If true, the rule will fail if the pattern matches.
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// (String) The operator to use for matching. Can be one of: starts_with, ends_with, contains, regex.
	// The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// (String) The pattern to match with.
	// The pattern to match with.
	Pattern *string `json:"pattern,omitempty" tf:"pattern,omitempty"`
}

type CommitAuthorEmailPatternParameters struct {

	// (String) How this rule will appear to users.
	// How this rule will appear to users.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Boolean) If true, the rule will fail if the pattern matches.
	// If true, the rule will fail if the pattern matches.
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// (String) The operator to use for matching. Can be one of: starts_with, ends_with, contains, regex.
	// The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
	// +kubebuilder:validation:Optional
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// (String) The pattern to match with.
	// The pattern to match with.
	// +kubebuilder:validation:Optional
	Pattern *string `json:"pattern" tf:"pattern,omitempty"`
}

type CommitMessagePatternInitParameters struct {

	// (String) How this rule will appear to users.
	// How this rule will appear to users.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Boolean) If true, the rule will fail if the pattern matches.
	// If true, the rule will fail if the pattern matches.
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// (String) The operator to use for matching. Can be one of: starts_with, ends_with, contains, regex.
	// The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// (String) The pattern to match with.
	// The pattern to match with.
	Pattern *string `json:"pattern,omitempty" tf:"pattern,omitempty"`
}

type CommitMessagePatternObservation struct {

	// (String) How this rule will appear to users.
	// How this rule will appear to users.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Boolean) If true, the rule will fail if the pattern matches.
	// If true, the rule will fail if the pattern matches.
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// (String) The operator to use for matching. Can be one of: starts_with, ends_with, contains, regex.
	// The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// (String) The pattern to match with.
	// The pattern to match with.
	Pattern *string `json:"pattern,omitempty" tf:"pattern,omitempty"`
}

type CommitMessagePatternParameters struct {

	// (String) How this rule will appear to users.
	// How this rule will appear to users.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Boolean) If true, the rule will fail if the pattern matches.
	// If true, the rule will fail if the pattern matches.
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// (String) The operator to use for matching. Can be one of: starts_with, ends_with, contains, regex.
	// The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
	// +kubebuilder:validation:Optional
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// (String) The pattern to match with.
	// The pattern to match with.
	// +kubebuilder:validation:Optional
	Pattern *string `json:"pattern" tf:"pattern,omitempty"`
}

type CommitterEmailPatternInitParameters struct {

	// (String) How this rule will appear to users.
	// How this rule will appear to users.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Boolean) If true, the rule will fail if the pattern matches.
	// If true, the rule will fail if the pattern matches.
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// (String) The operator to use for matching. Can be one of: starts_with, ends_with, contains, regex.
	// The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// (String) The pattern to match with.
	// The pattern to match with.
	Pattern *string `json:"pattern,omitempty" tf:"pattern,omitempty"`
}

type CommitterEmailPatternObservation struct {

	// (String) How this rule will appear to users.
	// How this rule will appear to users.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Boolean) If true, the rule will fail if the pattern matches.
	// If true, the rule will fail if the pattern matches.
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// (String) The operator to use for matching. Can be one of: starts_with, ends_with, contains, regex.
	// The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// (String) The pattern to match with.
	// The pattern to match with.
	Pattern *string `json:"pattern,omitempty" tf:"pattern,omitempty"`
}

type CommitterEmailPatternParameters struct {

	// (String) How this rule will appear to users.
	// How this rule will appear to users.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Boolean) If true, the rule will fail if the pattern matches.
	// If true, the rule will fail if the pattern matches.
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// (String) The operator to use for matching. Can be one of: starts_with, ends_with, contains, regex.
	// The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
	// +kubebuilder:validation:Optional
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// (String) The pattern to match with.
	// The pattern to match with.
	// +kubebuilder:validation:Optional
	Pattern *string `json:"pattern" tf:"pattern,omitempty"`
}

type ConditionsInitParameters struct {

	// (Block List, Min: 1, Max: 1) (see below for nested schema)
	RefName []RefNameInitParameters `json:"refName,omitempty" tf:"ref_name,omitempty"`
}

type ConditionsObservation struct {

	// (Block List, Min: 1, Max: 1) (see below for nested schema)
	RefName []RefNameObservation `json:"refName,omitempty" tf:"ref_name,omitempty"`
}

type ConditionsParameters struct {

	// (Block List, Min: 1, Max: 1) (see below for nested schema)
	// +kubebuilder:validation:Optional
	RefName []RefNameParameters `json:"refName" tf:"ref_name,omitempty"`
}

type MergeQueueInitParameters struct {

	// (Number)Maximum time for a required status check to report a conclusion. After this much time has elapsed, checks that have not reported a conclusion will be assumed to have failed. Defaults to 60.
	// Maximum time for a required status check to report a conclusion. After this much time has elapsed, checks that have not reported a conclusion will be assumed to have failed. Defaults to `60`.
	CheckResponseTimeoutMinutes *int64 `json:"checkResponseTimeoutMinutes,omitempty" tf:"check_response_timeout_minutes,omitempty"`

	// (String)When set to ALLGREEN, the merge commit created by merge queue for each PR in the group must pass all required checks to merge. When set to HEADGREEN, only the commit at the head of the merge group, i.e. the commit containing changes from all of the PRs in the group, must pass its required checks to merge. Can be one of: ALLGREEN, HEADGREEN. Defaults to ALLGREEN.
	// When set to ALLGREEN, the merge commit created by merge queue for each PR in the group must pass all required checks to merge. When set to HEADGREEN, only the commit at the head of the merge group, i.e. the commit containing changes from all of the PRs in the group, must pass its required checks to merge. Can be one of: ALLGREEN, HEADGREEN. Defaults to `ALLGREEN`.
	GroupingStrategy *string `json:"groupingStrategy,omitempty" tf:"grouping_strategy,omitempty"`

	// (Number) Limit the number of queued pull requests requesting checks and workflow runs at the same time. Defaults to 5.
	// Limit the number of queued pull requests requesting checks and workflow runs at the same time. Defaults to `5`.
	MaxEntriesToBuild *int64 `json:"maxEntriesToBuild,omitempty" tf:"max_entries_to_build,omitempty"`

	// (Number) Limit the number of queued pull requests requesting checks and workflow runs at the same time. Defaults to 5.
	// The maximum number of PRs that will be merged together in a group. Defaults to `5`.
	MaxEntriesToMerge *int64 `json:"maxEntriesToMerge,omitempty" tf:"max_entries_to_merge,omitempty"`

	// (String) Method to use when merging changes from queued pull requests. Can be one of: MERGE, SQUASH, REBASE. Defaults to MERGE.
	// Method to use when merging changes from queued pull requests. Can be one of: MERGE, SQUASH, REBASE. Defaults to `MERGE`.
	MergeMethod *string `json:"mergeMethod,omitempty" tf:"merge_method,omitempty"`

	// (Number) The minimum number of PRs that will be merged together in a group. Defaults to 1.
	// The minimum number of PRs that will be merged together in a group. Defaults to `1`.
	MinEntriesToMerge *int64 `json:"minEntriesToMerge,omitempty" tf:"min_entries_to_merge,omitempty"`

	// (Number) The time merge queue should wait after the first PR is added to the queue for the minimum group size to be met. After this time has elapsed, the minimum group size will be ignored and a smaller group will be merged. Defaults to 5.
	// The time merge queue should wait after the first PR is added to the queue for the minimum group size to be met. After this time has elapsed, the minimum group size will be ignored and a smaller group will be merged. Defaults to `5`.
	MinEntriesToMergeWaitMinutes *int64 `json:"minEntriesToMergeWaitMinutes,omitempty" tf:"min_entries_to_merge_wait_minutes,omitempty"`
}

type MergeQueueObservation struct {

	// (Number)Maximum time for a required status check to report a conclusion. After this much time has elapsed, checks that have not reported a conclusion will be assumed to have failed. Defaults to 60.
	// Maximum time for a required status check to report a conclusion. After this much time has elapsed, checks that have not reported a conclusion will be assumed to have failed. Defaults to `60`.
	CheckResponseTimeoutMinutes *int64 `json:"checkResponseTimeoutMinutes,omitempty" tf:"check_response_timeout_minutes,omitempty"`

	// (String)When set to ALLGREEN, the merge commit created by merge queue for each PR in the group must pass all required checks to merge. When set to HEADGREEN, only the commit at the head of the merge group, i.e. the commit containing changes from all of the PRs in the group, must pass its required checks to merge. Can be one of: ALLGREEN, HEADGREEN. Defaults to ALLGREEN.
	// When set to ALLGREEN, the merge commit created by merge queue for each PR in the group must pass all required checks to merge. When set to HEADGREEN, only the commit at the head of the merge group, i.e. the commit containing changes from all of the PRs in the group, must pass its required checks to merge. Can be one of: ALLGREEN, HEADGREEN. Defaults to `ALLGREEN`.
	GroupingStrategy *string `json:"groupingStrategy,omitempty" tf:"grouping_strategy,omitempty"`

	// (Number) Limit the number of queued pull requests requesting checks and workflow runs at the same time. Defaults to 5.
	// Limit the number of queued pull requests requesting checks and workflow runs at the same time. Defaults to `5`.
	MaxEntriesToBuild *int64 `json:"maxEntriesToBuild,omitempty" tf:"max_entries_to_build,omitempty"`

	// (Number) Limit the number of queued pull requests requesting checks and workflow runs at the same time. Defaults to 5.
	// The maximum number of PRs that will be merged together in a group. Defaults to `5`.
	MaxEntriesToMerge *int64 `json:"maxEntriesToMerge,omitempty" tf:"max_entries_to_merge,omitempty"`

	// (String) Method to use when merging changes from queued pull requests. Can be one of: MERGE, SQUASH, REBASE. Defaults to MERGE.
	// Method to use when merging changes from queued pull requests. Can be one of: MERGE, SQUASH, REBASE. Defaults to `MERGE`.
	MergeMethod *string `json:"mergeMethod,omitempty" tf:"merge_method,omitempty"`

	// (Number) The minimum number of PRs that will be merged together in a group. Defaults to 1.
	// The minimum number of PRs that will be merged together in a group. Defaults to `1`.
	MinEntriesToMerge *int64 `json:"minEntriesToMerge,omitempty" tf:"min_entries_to_merge,omitempty"`

	// (Number) The time merge queue should wait after the first PR is added to the queue for the minimum group size to be met. After this time has elapsed, the minimum group size will be ignored and a smaller group will be merged. Defaults to 5.
	// The time merge queue should wait after the first PR is added to the queue for the minimum group size to be met. After this time has elapsed, the minimum group size will be ignored and a smaller group will be merged. Defaults to `5`.
	MinEntriesToMergeWaitMinutes *int64 `json:"minEntriesToMergeWaitMinutes,omitempty" tf:"min_entries_to_merge_wait_minutes,omitempty"`
}

type MergeQueueParameters struct {

	// (Number)Maximum time for a required status check to report a conclusion. After this much time has elapsed, checks that have not reported a conclusion will be assumed to have failed. Defaults to 60.
	// Maximum time for a required status check to report a conclusion. After this much time has elapsed, checks that have not reported a conclusion will be assumed to have failed. Defaults to `60`.
	// +kubebuilder:validation:Optional
	CheckResponseTimeoutMinutes *int64 `json:"checkResponseTimeoutMinutes,omitempty" tf:"check_response_timeout_minutes,omitempty"`

	// (String)When set to ALLGREEN, the merge commit created by merge queue for each PR in the group must pass all required checks to merge. When set to HEADGREEN, only the commit at the head of the merge group, i.e. the commit containing changes from all of the PRs in the group, must pass its required checks to merge. Can be one of: ALLGREEN, HEADGREEN. Defaults to ALLGREEN.
	// When set to ALLGREEN, the merge commit created by merge queue for each PR in the group must pass all required checks to merge. When set to HEADGREEN, only the commit at the head of the merge group, i.e. the commit containing changes from all of the PRs in the group, must pass its required checks to merge. Can be one of: ALLGREEN, HEADGREEN. Defaults to `ALLGREEN`.
	// +kubebuilder:validation:Optional
	GroupingStrategy *string `json:"groupingStrategy,omitempty" tf:"grouping_strategy,omitempty"`

	// (Number) Limit the number of queued pull requests requesting checks and workflow runs at the same time. Defaults to 5.
	// Limit the number of queued pull requests requesting checks and workflow runs at the same time. Defaults to `5`.
	// +kubebuilder:validation:Optional
	MaxEntriesToBuild *int64 `json:"maxEntriesToBuild,omitempty" tf:"max_entries_to_build,omitempty"`

	// (Number) Limit the number of queued pull requests requesting checks and workflow runs at the same time. Defaults to 5.
	// The maximum number of PRs that will be merged together in a group. Defaults to `5`.
	// +kubebuilder:validation:Optional
	MaxEntriesToMerge *int64 `json:"maxEntriesToMerge,omitempty" tf:"max_entries_to_merge,omitempty"`

	// (String) Method to use when merging changes from queued pull requests. Can be one of: MERGE, SQUASH, REBASE. Defaults to MERGE.
	// Method to use when merging changes from queued pull requests. Can be one of: MERGE, SQUASH, REBASE. Defaults to `MERGE`.
	// +kubebuilder:validation:Optional
	MergeMethod *string `json:"mergeMethod,omitempty" tf:"merge_method,omitempty"`

	// (Number) The minimum number of PRs that will be merged together in a group. Defaults to 1.
	// The minimum number of PRs that will be merged together in a group. Defaults to `1`.
	// +kubebuilder:validation:Optional
	MinEntriesToMerge *int64 `json:"minEntriesToMerge,omitempty" tf:"min_entries_to_merge,omitempty"`

	// (Number) The time merge queue should wait after the first PR is added to the queue for the minimum group size to be met. After this time has elapsed, the minimum group size will be ignored and a smaller group will be merged. Defaults to 5.
	// The time merge queue should wait after the first PR is added to the queue for the minimum group size to be met. After this time has elapsed, the minimum group size will be ignored and a smaller group will be merged. Defaults to `5`.
	// +kubebuilder:validation:Optional
	MinEntriesToMergeWaitMinutes *int64 `json:"minEntriesToMergeWaitMinutes,omitempty" tf:"min_entries_to_merge_wait_minutes,omitempty"`
}

type RefNameInitParameters struct {

	// (List of String) Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match.
	// Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match.
	Exclude []*string `json:"exclude,omitempty" tf:"exclude,omitempty"`

	// (List of String) Array of ref names or patterns to include. One of these patterns must match for the condition to pass. Also accepts ~DEFAULT_BRANCH to include the default branch or ~ALL to include all branches.
	// Array of ref names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the default branch or `~ALL` to include all branches.
	Include []*string `json:"include,omitempty" tf:"include,omitempty"`
}

type RefNameObservation struct {

	// (List of String) Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match.
	// Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match.
	Exclude []*string `json:"exclude,omitempty" tf:"exclude,omitempty"`

	// (List of String) Array of ref names or patterns to include. One of these patterns must match for the condition to pass. Also accepts ~DEFAULT_BRANCH to include the default branch or ~ALL to include all branches.
	// Array of ref names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the default branch or `~ALL` to include all branches.
	Include []*string `json:"include,omitempty" tf:"include,omitempty"`
}

type RefNameParameters struct {

	// (List of String) Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match.
	// Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match.
	// +kubebuilder:validation:Optional
	Exclude []*string `json:"exclude" tf:"exclude,omitempty"`

	// (List of String) Array of ref names or patterns to include. One of these patterns must match for the condition to pass. Also accepts ~DEFAULT_BRANCH to include the default branch or ~ALL to include all branches.
	// Array of ref names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the default branch or `~ALL` to include all branches.
	// +kubebuilder:validation:Optional
	Include []*string `json:"include" tf:"include,omitempty"`
}

type RepositoryRulesetInitParameters struct {

	// (Block List) The actors that can bypass the rules in this ruleset. (see below for nested schema)
	// The actors that can bypass the rules in this ruleset.
	BypassActors []BypassActorsInitParameters `json:"bypassActors,omitempty" tf:"bypass_actors,omitempty"`

	// (Block List, Max: 1) Parameters for a repository ruleset ref name condition. (see below for nested schema)
	// Parameters for a repository ruleset ref name condition.
	Conditions []ConditionsInitParameters `json:"conditions,omitempty" tf:"conditions,omitempty"`

	// (String) Possible values for Enforcement are disabled, active, evaluate. Note: evaluate is currently only supported for owners of type organization.
	// Possible values for Enforcement are `disabled`, `active`, `evaluate`. Note: `evaluate` is currently only supported for owners of type `organization`.
	Enforcement *string `json:"enforcement,omitempty" tf:"enforcement,omitempty"`

	// (String) The name of the ruleset.
	// The name of the ruleset.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) Name of the repository to apply rulset to.
	// Name of the repository to apply rulset to.
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-upjet-github/apis/namespaced/repo/v1alpha1.Repository
	Repository *string `json:"repository,omitempty" tf:"repository,omitempty"`

	// Reference to a Repository in repo to populate repository.
	// +kubebuilder:validation:Optional
	RepositoryRef *v1.NamespacedReference `json:"repositoryRef,omitempty" tf:"-"`

	// Selector for a Repository in repo to populate repository.
	// +kubebuilder:validation:Optional
	RepositorySelector *v1.NamespacedSelector `json:"repositorySelector,omitempty" tf:"-"`

	// (Block List, Min: 1, Max: 1) Rules within the ruleset. (see below for nested schema)
	// Rules within the ruleset.
	Rules []RulesInitParameters `json:"rules,omitempty" tf:"rules,omitempty"`

	// (String) Possible values are branch and tag.
	// Possible values are `branch` and `tag`.
	Target *string `json:"target,omitempty" tf:"target,omitempty"`
}

type RepositoryRulesetObservation struct {

	// (Block List) The actors that can bypass the rules in this ruleset. (see below for nested schema)
	// The actors that can bypass the rules in this ruleset.
	BypassActors []BypassActorsObservation `json:"bypassActors,omitempty" tf:"bypass_actors,omitempty"`

	// (Block List, Max: 1) Parameters for a repository ruleset ref name condition. (see below for nested schema)
	// Parameters for a repository ruleset ref name condition.
	Conditions []ConditionsObservation `json:"conditions,omitempty" tf:"conditions,omitempty"`

	// (String) Possible values for Enforcement are disabled, active, evaluate. Note: evaluate is currently only supported for owners of type organization.
	// Possible values for Enforcement are `disabled`, `active`, `evaluate`. Note: `evaluate` is currently only supported for owners of type `organization`.
	Enforcement *string `json:"enforcement,omitempty" tf:"enforcement,omitempty"`

	// (String)
	Etag *string `json:"etag,omitempty" tf:"etag,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (String) The name of the ruleset.
	// The name of the ruleset.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) GraphQL global node id for use with v4 API.
	// GraphQL global node id for use with v4 API.
	NodeID *string `json:"nodeId,omitempty" tf:"node_id,omitempty"`

	// (String) Name of the repository to apply rulset to.
	// Name of the repository to apply rulset to.
	Repository *string `json:"repository,omitempty" tf:"repository,omitempty"`

	// (Block List, Min: 1, Max: 1) Rules within the ruleset. (see below for nested schema)
	// Rules within the ruleset.
	Rules []RulesObservation `json:"rules,omitempty" tf:"rules,omitempty"`

	// (Number) GitHub ID for the ruleset.
	// GitHub ID for the ruleset.
	RulesetID *int64 `json:"rulesetId,omitempty" tf:"ruleset_id,omitempty"`

	// (String) Possible values are branch and tag.
	// Possible values are `branch` and `tag`.
	Target *string `json:"target,omitempty" tf:"target,omitempty"`
}

type RepositoryRulesetParameters struct {

	// (Block List) The actors that can bypass the rules in this ruleset. (see below for nested schema)
	// The actors that can bypass the rules in this ruleset.
	// +kubebuilder:validation:Optional
	BypassActors []BypassActorsParameters `json:"bypassActors,omitempty" tf:"bypass_actors,omitempty"`

	// (Block List, Max: 1) Parameters for a repository ruleset ref name condition. (see below for nested schema)
	// Parameters for a repository ruleset ref name condition.
	// +kubebuilder:validation:Optional
	Conditions []ConditionsParameters `json:"conditions,omitempty" tf:"conditions,omitempty"`

	// (String) Possible values for Enforcement are disabled, active, evaluate. Note: evaluate is currently only supported for owners of type organization.
	// Possible values for Enforcement are `disabled`, `active`, `evaluate`. Note: `evaluate` is currently only supported for owners of type `organization`.
	// +kubebuilder:validation:Optional
	Enforcement *string `json:"enforcement,omitempty" tf:"enforcement,omitempty"`

	// (String) The name of the ruleset.
	// The name of the ruleset.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (String) Name of the repository to apply rulset to.
	// Name of the repository to apply rulset to.
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-upjet-github/apis/namespaced/repo/v1alpha1.Repository
	// +kubebuilder:validation:Optional
	Repository *string `json:"repository,omitempty" tf:"repository,omitempty"`

	// Reference to a Repository in repo to populate repository.
	// +kubebuilder:validation:Optional
	RepositoryRef *v1.NamespacedReference `json:"repositoryRef,omitempty" tf:"-"`

	// Selector for a Repository in repo to populate repository.
	// +kubebuilder:validation:Optional
	RepositorySelector *v1.NamespacedSelector `json:"repositorySelector,omitempty" tf:"-"`

	// (Block List, Min: 1, Max: 1) Rules within the ruleset. (see below for nested schema)
	// Rules within the ruleset.
	// +kubebuilder:validation:Optional
	Rules []RulesParameters `json:"rules,omitempty" tf:"rules,omitempty"`

	// (String) Possible values are branch and tag.
	// Possible values are `branch` and `tag`.
	// +kubebuilder:validation:Optional
	Target *string `json:"target,omitempty" tf:"target,omitempty"`
}

type RequiredCheckInitParameters struct {

	// (String) The status check context name that must be present on the commit.
	// The status check context name that must be present on the commit.
	Context *string `json:"context,omitempty" tf:"context,omitempty"`

	// (Number) The optional integration ID that this status check must originate from. It's a GitHub App ID, which can be obtained by following instructions from the Get an App API docs.
	// The optional integration ID that this status check must originate from.
	IntegrationID *int64 `json:"integrationId,omitempty" tf:"integration_id,omitempty"`
}

type RequiredCheckObservation struct {

	// (String) The status check context name that must be present on the commit.
	// The status check context name that must be present on the commit.
	Context *string `json:"context,omitempty" tf:"context,omitempty"`

	// (Number) The optional integration ID that this status check must originate from. It's a GitHub App ID, which can be obtained by following instructions from the Get an App API docs.
	// The optional integration ID that this status check must originate from.
	IntegrationID *int64 `json:"integrationId,omitempty" tf:"integration_id,omitempty"`
}

type RequiredCheckParameters struct {

	// (String) The status check context name that must be present on the commit.
	// The status check context name that must be present on the commit.
	// +kubebuilder:validation:Optional
	Context *string `json:"context" tf:"context,omitempty"`

	// (Number) The optional integration ID that this status check must originate from. It's a GitHub App ID, which can be obtained by following instructions from the Get an App API docs.
	// The optional integration ID that this status check must originate from.
	// +kubebuilder:validation:Optional
	IntegrationID *int64 `json:"integrationId,omitempty" tf:"integration_id,omitempty"`
}

type RequiredCodeScanningInitParameters struct {

	// (Block Set, Min: 1) Actions code scanning tools that are required. Multiple can be defined. (see below for nested schema)
	// Tools that must provide code scanning results for this rule to pass.
	RequiredCodeScanningTool []RequiredCodeScanningToolInitParameters `json:"requiredCodeScanningTool,omitempty" tf:"required_code_scanning_tool,omitempty"`
}

type RequiredCodeScanningObservation struct {

	// (Block Set, Min: 1) Actions code scanning tools that are required. Multiple can be defined. (see below for nested schema)
	// Tools that must provide code scanning results for this rule to pass.
	RequiredCodeScanningTool []RequiredCodeScanningToolObservation `json:"requiredCodeScanningTool,omitempty" tf:"required_code_scanning_tool,omitempty"`
}

type RequiredCodeScanningParameters struct {

	// (Block Set, Min: 1) Actions code scanning tools that are required. Multiple can be defined. (see below for nested schema)
	// Tools that must provide code scanning results for this rule to pass.
	// +kubebuilder:validation:Optional
	RequiredCodeScanningTool []RequiredCodeScanningToolParameters `json:"requiredCodeScanningTool" tf:"required_code_scanning_tool,omitempty"`
}

type RequiredCodeScanningToolInitParameters struct {

	// (String) The severity level at which code scanning results that raise alerts block a reference update. Can be one of: none, errors, errors_and_warnings, all.
	// The severity level at which code scanning results that raise alerts block a reference update. Can be one of: `none`, `errors`, `errors_and_warnings`, `all`.
	AlertsThreshold *string `json:"alertsThreshold,omitempty" tf:"alerts_threshold,omitempty"`

	// (String) The severity level at which code scanning results that raise security alerts block a reference update. Can be one of: none, critical, high_or_higher, medium_or_higher, all.
	// The severity level at which code scanning results that raise security alerts block a reference update. Can be one of: `none`, `critical`, `high_or_higher`, `medium_or_higher`, `all`.
	SecurityAlertsThreshold *string `json:"securityAlertsThreshold,omitempty" tf:"security_alerts_threshold,omitempty"`

	// (String) The name of a code scanning tool.
	// The name of a code scanning tool
	Tool *string `json:"tool,omitempty" tf:"tool,omitempty"`
}

type RequiredCodeScanningToolObservation struct {

	// (String) The severity level at which code scanning results that raise alerts block a reference update. Can be one of: none, errors, errors_and_warnings, all.
	// The severity level at which code scanning results that raise alerts block a reference update. Can be one of: `none`, `errors`, `errors_and_warnings`, `all`.
	AlertsThreshold *string `json:"alertsThreshold,omitempty" tf:"alerts_threshold,omitempty"`

	// (String) The severity level at which code scanning results that raise security alerts block a reference update. Can be one of: none, critical, high_or_higher, medium_or_higher, all.
	// The severity level at which code scanning results that raise security alerts block a reference update. Can be one of: `none`, `critical`, `high_or_higher`, `medium_or_higher`, `all`.
	SecurityAlertsThreshold *string `json:"securityAlertsThreshold,omitempty" tf:"security_alerts_threshold,omitempty"`

	// (String) The name of a code scanning tool.
	// The name of a code scanning tool
	Tool *string `json:"tool,omitempty" tf:"tool,omitempty"`
}

type RequiredCodeScanningToolParameters struct {

	// (String) The severity level at which code scanning results that raise alerts block a reference update. Can be one of: none, errors, errors_and_warnings, all.
	// The severity level at which code scanning results that raise alerts block a reference update. Can be one of: `none`, `errors`, `errors_and_warnings`, `all`.
	// +kubebuilder:validation:Optional
	AlertsThreshold *string `json:"alertsThreshold" tf:"alerts_threshold,omitempty"`

	// (String) The severity level at which code scanning results that raise security alerts block a reference update. Can be one of: none, critical, high_or_higher, medium_or_higher, all.
	// The severity level at which code scanning results that raise security alerts block a reference update. Can be one of: `none`, `critical`, `high_or_higher`, `medium_or_higher`, `all`.
	// +kubebuilder:validation:Optional
	SecurityAlertsThreshold *string `json:"securityAlertsThreshold" tf:"security_alerts_threshold,omitempty"`

	// (String) The name of a code scanning tool.
	// The name of a code scanning tool
	// +kubebuilder:validation:Optional
	Tool *string `json:"tool" tf:"tool,omitempty"`
}

type RequiredDeploymentsInitParameters struct {

	// (List of String) The environments that must be successfully deployed to before branches can be merged.
	// The environments that must be successfully deployed to before branches can be merged.
	RequiredDeploymentEnvironments []*string `json:"requiredDeploymentEnvironments,omitempty" tf:"required_deployment_environments,omitempty"`
}

type RequiredDeploymentsObservation struct {

	// (List of String) The environments that must be successfully deployed to before branches can be merged.
	// The environments that must be successfully deployed to before branches can be merged.
	RequiredDeploymentEnvironments []*string `json:"requiredDeploymentEnvironments,omitempty" tf:"required_deployment_environments,omitempty"`
}

type RequiredDeploymentsParameters struct {

	// (List of String) The environments that must be successfully deployed to before branches can be merged.
	// The environments that must be successfully deployed to before branches can be merged.
	// +kubebuilder:validation:Optional
	RequiredDeploymentEnvironments []*string `json:"requiredDeploymentEnvironments" tf:"required_deployment_environments,omitempty"`
}

type RulesInitParameters struct {

	// (Block List, Max: 1) Parameters to be used for the branch_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with tag_name_pattern as it only applied to rulesets with target branch. (see below for nested schema)
	// Parameters to be used for the branch_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `tag_name_pattern` as it only applies to rulesets with target `branch`.
	BranchNamePattern []BranchNamePatternInitParameters `json:"branchNamePattern,omitempty" tf:"branch_name_pattern,omitempty"`

	// (Block List, Max: 1) Parameters to be used for the commit_author_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
	// Parameters to be used for the commit_author_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations.
	CommitAuthorEmailPattern []CommitAuthorEmailPatternInitParameters `json:"commitAuthorEmailPattern,omitempty" tf:"commit_author_email_pattern,omitempty"`

	// (Block List, Max: 1) Parameters to be used for the commit_message_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
	// Parameters to be used for the commit_message_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations.
	CommitMessagePattern []CommitMessagePatternInitParameters `json:"commitMessagePattern,omitempty" tf:"commit_message_pattern,omitempty"`

	// (Block List, Max: 1) Parameters to be used for the committer_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
	// Parameters to be used for the committer_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations.
	CommitterEmailPattern []CommitterEmailPatternInitParameters `json:"committerEmailPattern,omitempty" tf:"committer_email_pattern,omitempty"`

	// (Boolean) Only allow users with bypass permission to create matching refs.
	// Only allow users with bypass permission to create matching refs.
	Creation *bool `json:"creation,omitempty" tf:"creation,omitempty"`

	// (Boolean) Only allow users with bypass permissions to delete matching refs.
	// Only allow users with bypass permissions to delete matching refs.
	Deletion *bool `json:"deletion,omitempty" tf:"deletion,omitempty"`

	// (Block List, Max: 1) Merges must be performed via a merge queue.
	// Merges must be performed via a merge queue.
	MergeQueue []MergeQueueInitParameters `json:"mergeQueue,omitempty" tf:"merge_queue,omitempty"`

	// (Boolean) Prevent users with push access from force pushing to branches.
	// Prevent users with push access from force pushing to branches.
	NonFastForward *bool `json:"nonFastForward,omitempty" tf:"non_fast_forward,omitempty"`

	// (Block List, Max: 1) Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. (see below for nested schema)
	// Require all commits be made to a non-target branch and submitted via a pull request before they can be merged.
	PullRequest []RulesPullRequestInitParameters `json:"pullRequest,omitempty" tf:"pull_request,omitempty"`

	// (Block List, Max: 1) Define which tools must provide code scanning results before the reference is updated. When configured, code scanning must be enabled and have results for both the commit and the reference being updated. Multiple code scanning tools can be specified. (see below for nested schema)
	// Choose which tools must provide code scanning results before the reference is updated. When configured, code scanning must be enabled and have results for both the commit and the reference being updated.
	RequiredCodeScanning []RequiredCodeScanningInitParameters `json:"requiredCodeScanning,omitempty" tf:"required_code_scanning,omitempty"`

	// (Block List, Max: 1) Choose which environments must be successfully deployed to before branches can be merged into a branch that matches this rule. (see below for nested schema)
	// Choose which environments must be successfully deployed to before branches can be merged into a branch that matches this rule.
	RequiredDeployments []RequiredDeploymentsInitParameters `json:"requiredDeployments,omitempty" tf:"required_deployments,omitempty"`

	// (Boolean) Prevent merge commits from being pushed to matching branches.
	// Prevent merge commits from being pushed to matching branches.
	RequiredLinearHistory *bool `json:"requiredLinearHistory,omitempty" tf:"required_linear_history,omitempty"`

	// (Boolean) Commits pushed to matching branches must have verified signatures.
	// Commits pushed to matching branches must have verified signatures.
	RequiredSignatures *bool `json:"requiredSignatures,omitempty" tf:"required_signatures,omitempty"`

	// (Block List, Max: 1) Choose which status checks must pass before branches can be merged into a branch that matches this rule. When enabled, commits must first be pushed to another branch, then merged or pushed directly to a branch that matches this rule after status checks have passed. (see below for nested schema)
	// Choose which status checks must pass before branches can be merged into a branch that matches this rule. When enabled, commits must first be pushed to another branch, then merged or pushed directly to a branch that matches this rule after status checks have passed.
	RequiredStatusChecks []RulesRequiredStatusChecksInitParameters `json:"requiredStatusChecks,omitempty" tf:"required_status_checks,omitempty"`

	// (Block List, Max: 1) Parameters to be used for the tag_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with branch_name_pattern as it only applied to rulesets with target tag. (see below for nested schema)
	// Parameters to be used for the tag_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `branch_name_pattern` as it only applies to rulesets with target `tag`.
	TagNamePattern []TagNamePatternInitParameters `json:"tagNamePattern,omitempty" tf:"tag_name_pattern,omitempty"`

	// (Boolean) Only allow users with bypass permission to update matching refs.
	// Only allow users with bypass permission to update matching refs.
	Update *bool `json:"update,omitempty" tf:"update,omitempty"`

	// (Boolean) Branch can pull changes from its upstream repository. This is only applicable to forked repositories. Requires update to be set to true. Note: behaviour is affected by a known bug on the GitHub side which may cause issues when using this parameter.
	// Branch can pull changes from its upstream repository. This is only applicable to forked repositories. Requires `update` to be set to `true`.
	UpdateAllowsFetchAndMerge *bool `json:"updateAllowsFetchAndMerge,omitempty" tf:"update_allows_fetch_and_merge,omitempty"`
}

type RulesObservation struct {

	// (Block List, Max: 1) Parameters to be used for the branch_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with tag_name_pattern as it only applied to rulesets with target branch. (see below for nested schema)
	// Parameters to be used for the branch_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `tag_name_pattern` as it only applies to rulesets with target `branch`.
	BranchNamePattern []BranchNamePatternObservation `json:"branchNamePattern,omitempty" tf:"branch_name_pattern,omitempty"`

	// (Block List, Max: 1) Parameters to be used for the commit_author_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
	// Parameters to be used for the commit_author_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations.
	CommitAuthorEmailPattern []CommitAuthorEmailPatternObservation `json:"commitAuthorEmailPattern,omitempty" tf:"commit_author_email_pattern,omitempty"`

	// (Block List, Max: 1) Parameters to be used for the commit_message_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
	// Parameters to be used for the commit_message_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations.
	CommitMessagePattern []CommitMessagePatternObservation `json:"commitMessagePattern,omitempty" tf:"commit_message_pattern,omitempty"`

	// (Block List, Max: 1) Parameters to be used for the committer_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
	// Parameters to be used for the committer_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations.
	CommitterEmailPattern []CommitterEmailPatternObservation `json:"committerEmailPattern,omitempty" tf:"committer_email_pattern,omitempty"`

	// (Boolean) Only allow users with bypass permission to create matching refs.
	// Only allow users with bypass permission to create matching refs.
	Creation *bool `json:"creation,omitempty" tf:"creation,omitempty"`

	// (Boolean) Only allow users with bypass permissions to delete matching refs.
	// Only allow users with bypass permissions to delete matching refs.
	Deletion *bool `json:"deletion,omitempty" tf:"deletion,omitempty"`

	// (Block List, Max: 1) Merges must be performed via a merge queue.
	// Merges must be performed via a merge queue.
	MergeQueue []MergeQueueObservation `json:"mergeQueue,omitempty" tf:"merge_queue,omitempty"`

	// (Boolean) Prevent users with push access from force pushing to branches.
	// Prevent users with push access from force pushing to branches.
	NonFastForward *bool `json:"nonFastForward,omitempty" tf:"non_fast_forward,omitempty"`

	// (Block List, Max: 1) Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. (see below for nested schema)
	// Require all commits be made to a non-target branch and submitted via a pull request before they can be merged.
	PullRequest []RulesPullRequestObservation `json:"pullRequest,omitempty" tf:"pull_request,omitempty"`

	// (Block List, Max: 1) Define which tools must provide code scanning results before the reference is updated. When configured, code scanning must be enabled and have results for both the commit and the reference being updated. Multiple code scanning tools can be specified. (see below for nested schema)
	// Choose which tools must provide code scanning results before the reference is updated. When configured, code scanning must be enabled and have results for both the commit and the reference being updated.
	RequiredCodeScanning []RequiredCodeScanningObservation `json:"requiredCodeScanning,omitempty" tf:"required_code_scanning,omitempty"`

	// (Block List, Max: 1) Choose which environments must be successfully deployed to before branches can be merged into a branch that matches this rule. (see below for nested schema)
	// Choose which environments must be successfully deployed to before branches can be merged into a branch that matches this rule.
	RequiredDeployments []RequiredDeploymentsObservation `json:"requiredDeployments,omitempty" tf:"required_deployments,omitempty"`

	// (Boolean) Prevent merge commits from being pushed to matching branches.
	// Prevent merge commits from being pushed to matching branches.
	RequiredLinearHistory *bool `json:"requiredLinearHistory,omitempty" tf:"required_linear_history,omitempty"`

	// (Boolean) Commits pushed to matching branches must have verified signatures.
	// Commits pushed to matching branches must have verified signatures.
	RequiredSignatures *bool `json:"requiredSignatures,omitempty" tf:"required_signatures,omitempty"`

	// (Block List, Max: 1) Choose which status checks must pass before branches can be merged into a branch that matches this rule. When enabled, commits must first be pushed to another branch, then merged or pushed directly to a branch that matches this rule after status checks have passed. (see below for nested schema)
	// Choose which status checks must pass before branches can be merged into a branch that matches this rule. When enabled, commits must first be pushed to another branch, then merged or pushed directly to a branch that matches this rule after status checks have passed.
	RequiredStatusChecks []RulesRequiredStatusChecksObservation `json:"requiredStatusChecks,omitempty" tf:"required_status_checks,omitempty"`

	// (Block List, Max: 1) Parameters to be used for the tag_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with branch_name_pattern as it only applied to rulesets with target tag. (see below for nested schema)
	// Parameters to be used for the tag_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `branch_name_pattern` as it only applies to rulesets with target `tag`.
	TagNamePattern []TagNamePatternObservation `json:"tagNamePattern,omitempty" tf:"tag_name_pattern,omitempty"`

	// (Boolean) Only allow users with bypass permission to update matching refs.
	// Only allow users with bypass permission to update matching refs.
	Update *bool `json:"update,omitempty" tf:"update,omitempty"`

	// (Boolean) Branch can pull changes from its upstream repository. This is only applicable to forked repositories. Requires update to be set to true. Note: behaviour is affected by a known bug on the GitHub side which may cause issues when using this parameter.
	// Branch can pull changes from its upstream repository. This is only applicable to forked repositories. Requires `update` to be set to `true`.
	UpdateAllowsFetchAndMerge *bool `json:"updateAllowsFetchAndMerge,omitempty" tf:"update_allows_fetch_and_merge,omitempty"`
}

type RulesParameters struct {

	// (Block List, Max: 1) Parameters to be used for the branch_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with tag_name_pattern as it only applied to rulesets with target branch. (see below for nested schema)
	// Parameters to be used for the branch_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `tag_name_pattern` as it only applies to rulesets with target `branch`.
	// +kubebuilder:validation:Optional
	BranchNamePattern []BranchNamePatternParameters `json:"branchNamePattern,omitempty" tf:"branch_name_pattern,omitempty"`

	// (Block List, Max: 1) Parameters to be used for the commit_author_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
	// Parameters to be used for the commit_author_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations.
	// +kubebuilder:validation:Optional
	CommitAuthorEmailPattern []CommitAuthorEmailPatternParameters `json:"commitAuthorEmailPattern,omitempty" tf:"commit_author_email_pattern,omitempty"`

	// (Block List, Max: 1) Parameters to be used for the commit_message_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
	// Parameters to be used for the commit_message_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations.
	// +kubebuilder:validation:Optional
	CommitMessagePattern []CommitMessagePatternParameters `json:"commitMessagePattern,omitempty" tf:"commit_message_pattern,omitempty"`

	// (Block List, Max: 1) Parameters to be used for the committer_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. (see below for nested schema)
	// Parameters to be used for the committer_email_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations.
	// +kubebuilder:validation:Optional
	CommitterEmailPattern []CommitterEmailPatternParameters `json:"committerEmailPattern,omitempty" tf:"committer_email_pattern,omitempty"`

	// (Boolean) Only allow users with bypass permission to create matching refs.
	// Only allow users with bypass permission to create matching refs.
	// +kubebuilder:validation:Optional
	Creation *bool `json:"creation,omitempty" tf:"creation,omitempty"`

	// (Boolean) Only allow users with bypass permissions to delete matching refs.
	// Only allow users with bypass permissions to delete matching refs.
	// +kubebuilder:validation:Optional
	Deletion *bool `json:"deletion,omitempty" tf:"deletion,omitempty"`

	// (Block List, Max: 1) Merges must be performed via a merge queue.
	// Merges must be performed via a merge queue.
	// +kubebuilder:validation:Optional
	MergeQueue []MergeQueueParameters `json:"mergeQueue,omitempty" tf:"merge_queue,omitempty"`

	// (Boolean) Prevent users with push access from force pushing to branches.
	// Prevent users with push access from force pushing to branches.
	// +kubebuilder:validation:Optional
	NonFastForward *bool `json:"nonFastForward,omitempty" tf:"non_fast_forward,omitempty"`

	// (Block List, Max: 1) Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. (see below for nested schema)
	// Require all commits be made to a non-target branch and submitted via a pull request before they can be merged.
	// +kubebuilder:validation:Optional
	PullRequest []RulesPullRequestParameters `json:"pullRequest,omitempty" tf:"pull_request,omitempty"`

	// (Block List, Max: 1) Define which tools must provide code scanning results before the reference is updated. When configured, code scanning must be enabled and have results for both the commit and the reference being updated. Multiple code scanning tools can be specified. (see below for nested schema)
	// Choose which tools must provide code scanning results before the reference is updated. When configured, code scanning must be enabled and have results for both the commit and the reference being updated.
	// +kubebuilder:validation:Optional
	RequiredCodeScanning []RequiredCodeScanningParameters `json:"requiredCodeScanning,omitempty" tf:"required_code_scanning,omitempty"`

	// (Block List, Max: 1) Choose which environments must be successfully deployed to before branches can be merged into a branch that matches this rule. (see below for nested schema)
	// Choose which environments must be successfully deployed to before branches can be merged into a branch that matches this rule.
	// +kubebuilder:validation:Optional
	RequiredDeployments []RequiredDeploymentsParameters `json:"requiredDeployments,omitempty" tf:"required_deployments,omitempty"`

	// (Boolean) Prevent merge commits from being pushed to matching branches.
	// Prevent merge commits from being pushed to matching branches.
	// +kubebuilder:validation:Optional
	RequiredLinearHistory *bool `json:"requiredLinearHistory,omitempty" tf:"required_linear_history,omitempty"`

	// (Boolean) Commits pushed to matching branches must have verified signatures.
	// Commits pushed to matching branches must have verified signatures.
	// +kubebuilder:validation:Optional
	RequiredSignatures *bool `json:"requiredSignatures,omitempty" tf:"required_signatures,omitempty"`

	// (Block List, Max: 1) Choose which status checks must pass before branches can be merged into a branch that matches this rule. When enabled, commits must first be pushed to another branch, then merged or pushed directly to a branch that matches this rule after status checks have passed. (see below for nested schema)
	// Choose which status checks must pass before branches can be merged into a branch that matches this rule. When enabled, commits must first be pushed to another branch, then merged or pushed directly to a branch that matches this rule after status checks have passed.
	// +kubebuilder:validation:Optional
	RequiredStatusChecks []RulesRequiredStatusChecksParameters `json:"requiredStatusChecks,omitempty" tf:"required_status_checks,omitempty"`

	// (Block List, Max: 1) Parameters to be used for the tag_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with branch_name_pattern as it only applied to rulesets with target tag. (see below for nested schema)
	// Parameters to be used for the tag_name_pattern rule. This rule only applies to repositories within an enterprise, it cannot be applied to repositories owned by individuals or regular organizations. Conflicts with `branch_name_pattern` as it only applies to rulesets with target `tag`.
	// +kubebuilder:validation:Optional
	TagNamePattern []TagNamePatternParameters `json:"tagNamePattern,omitempty" tf:"tag_name_pattern,omitempty"`

	// (Boolean) Only allow users with bypass permission to update matching refs.
	// Only allow users with bypass permission to update matching refs.
	// +kubebuilder:validation:Optional
	Update *bool `json:"update,omitempty" tf:"update,omitempty"`

	// (Boolean) Branch can pull changes from its upstream repository. This is only applicable to forked repositories. Requires update to be set to true. Note: behaviour is affected by a known bug on the GitHub side which may cause issues when using this parameter.
	// Branch can pull changes from its upstream repository. This is only applicable to forked repositories. Requires `update` to be set to `true`.
	// +kubebuilder:validation:Optional
	UpdateAllowsFetchAndMerge *bool `json:"updateAllowsFetchAndMerge,omitempty" tf:"update_allows_fetch_and_merge,omitempty"`
}

type RulesPullRequestInitParameters struct {

	// (Boolean) New, reviewable commits pushed will dismiss previous pull request review approvals. Defaults to false.
	// New, reviewable commits pushed will dismiss previous pull request review approvals. Defaults to `false`.
	DismissStaleReviewsOnPush *bool `json:"dismissStaleReviewsOnPush,omitempty" tf:"dismiss_stale_reviews_on_push,omitempty"`

	// (Boolean) Require an approving review in pull requests that modify files that have a designated code owner. Defaults to false.
	// Require an approving review in pull requests that modify files that have a designated code owner. Defaults to `false`.
	RequireCodeOwnerReview *bool `json:"requireCodeOwnerReview,omitempty" tf:"require_code_owner_review,omitempty"`

	// (Boolean) Whether the most recent reviewable push must be approved by someone other than the person who pushed it. Defaults to false.
	// Whether the most recent reviewable push must be approved by someone other than the person who pushed it. Defaults to `false`.
	RequireLastPushApproval *bool `json:"requireLastPushApproval,omitempty" tf:"require_last_push_approval,omitempty"`

	// (Number) The number of approving reviews that are required before a pull request can be merged. Defaults to 0.
	// The number of approving reviews that are required before a pull request can be merged. Defaults to `0`.
	RequiredApprovingReviewCount *int64 `json:"requiredApprovingReviewCount,omitempty" tf:"required_approving_review_count,omitempty"`

	// (Boolean) All conversations on code must be resolved before a pull request can be merged. Defaults to false.
	// All conversations on code must be resolved before a pull request can be merged. Defaults to `false`.
	RequiredReviewThreadResolution *bool `json:"requiredReviewThreadResolution,omitempty" tf:"required_review_thread_resolution,omitempty"`
}

type RulesPullRequestObservation struct {

	// (Boolean) New, reviewable commits pushed will dismiss previous pull request review approvals. Defaults to false.
	// New, reviewable commits pushed will dismiss previous pull request review approvals. Defaults to `false`.
	DismissStaleReviewsOnPush *bool `json:"dismissStaleReviewsOnPush,omitempty" tf:"dismiss_stale_reviews_on_push,omitempty"`

	// (Boolean) Require an approving review in pull requests that modify files that have a designated code owner. Defaults to false.
	// Require an approving review in pull requests that modify files that have a designated code owner. Defaults to `false`.
	RequireCodeOwnerReview *bool `json:"requireCodeOwnerReview,omitempty" tf:"require_code_owner_review,omitempty"`

	// (Boolean) Whether the most recent reviewable push must be approved by someone other than the person who pushed it. Defaults to false.
	// Whether the most recent reviewable push must be approved by someone other than the person who pushed it. Defaults to `false`.
	RequireLastPushApproval *bool `json:"requireLastPushApproval,omitempty" tf:"require_last_push_approval,omitempty"`

	// (Number) The number of approving reviews that are required before a pull request can be merged. Defaults to 0.
	// The number of approving reviews that are required before a pull request can be merged. Defaults to `0`.
	RequiredApprovingReviewCount *int64 `json:"requiredApprovingReviewCount,omitempty" tf:"required_approving_review_count,omitempty"`

	// (Boolean) All conversations on code must be resolved before a pull request can be merged. Defaults to false.
	// All conversations on code must be resolved before a pull request can be merged. Defaults to `false`.
	RequiredReviewThreadResolution *bool `json:"requiredReviewThreadResolution,omitempty" tf:"required_review_thread_resolution,omitempty"`
}

type RulesPullRequestParameters struct {

	// (Boolean) New, reviewable commits pushed will dismiss previous pull request review approvals. Defaults to false.
	// New, reviewable commits pushed will dismiss previous pull request review approvals. Defaults to `false`.
	// +kubebuilder:validation:Optional
	DismissStaleReviewsOnPush *bool `json:"dismissStaleReviewsOnPush,omitempty" tf:"dismiss_stale_reviews_on_push,omitempty"`

	// (Boolean) Require an approving review in pull requests that modify files that have a designated code owner. Defaults to false.
	// Require an approving review in pull requests that modify files that have a designated code owner. Defaults to `false`.
	// +kubebuilder:validation:Optional
	RequireCodeOwnerReview *bool `json:"requireCodeOwnerReview,omitempty" tf:"require_code_owner_review,omitempty"`

	// (Boolean) Whether the most recent reviewable push must be approved by someone other than the person who pushed it. Defaults to false.
	// Whether the most recent reviewable push must be approved by someone other than the person who pushed it. Defaults to `false`.
	// +kubebuilder:validation:Optional
	RequireLastPushApproval *bool `json:"requireLastPushApproval,omitempty" tf:"require_last_push_approval,omitempty"`

	// (Number) The number of approving reviews that are required before a pull request can be merged. Defaults to 0.
	// The number of approving reviews that are required before a pull request can be merged. Defaults to `0`.
	// +kubebuilder:validation:Optional
	RequiredApprovingReviewCount *int64 `json:"requiredApprovingReviewCount,omitempty" tf:"required_approving_review_count,omitempty"`

	// (Boolean) All conversations on code must be resolved before a pull request can be merged. Defaults to false.
	// All conversations on code must be resolved before a pull request can be merged. Defaults to `false`.
	// +kubebuilder:validation:Optional
	RequiredReviewThreadResolution *bool `json:"requiredReviewThreadResolution,omitempty" tf:"required_review_thread_resolution,omitempty"`
}

type RulesRequiredStatusChecksInitParameters struct {

	// (Boolean) Allow repositories and branches to be created if a check would otherwise prohibit it. Defaults to false.
	// Allow repositories and branches to be created if a check would otherwise prohibit it.
	DoNotEnforceOnCreate *bool `json:"doNotEnforceOnCreate,omitempty" tf:"do_not_enforce_on_create,omitempty"`

	// (Block Set, Min: 1) Status checks that are required. Several can be defined. (see below for nested schema)
	// Status checks that are required. Several can be defined.
	RequiredCheck []RequiredCheckInitParameters `json:"requiredCheck,omitempty" tf:"required_check,omitempty"`

	// (Boolean) Whether pull requests targeting a matching branch must be tested with the latest code. This setting will not take effect unless at least one status check is enabled. Defaults to false.
	// Whether pull requests targeting a matching branch must be tested with the latest code. This setting will not take effect unless at least one status check is enabled. Defaults to `false`.
	StrictRequiredStatusChecksPolicy *bool `json:"strictRequiredStatusChecksPolicy,omitempty" tf:"strict_required_status_checks_policy,omitempty"`
}

type RulesRequiredStatusChecksObservation struct {

	// (Boolean) Allow repositories and branches to be created if a check would otherwise prohibit it. Defaults to false.
	// Allow repositories and branches to be created if a check would otherwise prohibit it.
	DoNotEnforceOnCreate *bool `json:"doNotEnforceOnCreate,omitempty" tf:"do_not_enforce_on_create,omitempty"`

	// (Block Set, Min: 1) Status checks that are required. Several can be defined. (see below for nested schema)
	// Status checks that are required. Several can be defined.
	RequiredCheck []RequiredCheckObservation `json:"requiredCheck,omitempty" tf:"required_check,omitempty"`

	// (Boolean) Whether pull requests targeting a matching branch must be tested with the latest code. This setting will not take effect unless at least one status check is enabled. Defaults to false.
	// Whether pull requests targeting a matching branch must be tested with the latest code. This setting will not take effect unless at least one status check is enabled. Defaults to `false`.
	StrictRequiredStatusChecksPolicy *bool `json:"strictRequiredStatusChecksPolicy,omitempty" tf:"strict_required_status_checks_policy,omitempty"`
}

type RulesRequiredStatusChecksParameters struct {

	// (Boolean) Allow repositories and branches to be created if a check would otherwise prohibit it. Defaults to false.
	// Allow repositories and branches to be created if a check would otherwise prohibit it.
	// +kubebuilder:validation:Optional
	DoNotEnforceOnCreate *bool `json:"doNotEnforceOnCreate,omitempty" tf:"do_not_enforce_on_create,omitempty"`

	// (Block Set, Min: 1) Status checks that are required. Several can be defined. (see below for nested schema)
	// Status checks that are required. Several can be defined.
	// +kubebuilder:validation:Optional
	RequiredCheck []RequiredCheckParameters `json:"requiredCheck" tf:"required_check,omitempty"`

	// (Boolean) Whether pull requests targeting a matching branch must be tested with the latest code. This setting will not take effect unless at least one status check is enabled. Defaults to false.
	// Whether pull requests targeting a matching branch must be tested with the latest code. This setting will not take effect unless at least one status check is enabled. Defaults to `false`.
	// +kubebuilder:validation:Optional
	StrictRequiredStatusChecksPolicy *bool `json:"strictRequiredStatusChecksPolicy,omitempty" tf:"strict_required_status_checks_policy,omitempty"`
}

type TagNamePatternInitParameters struct {

	// (String) How this rule will appear to users.
	// How this rule will appear to users.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Boolean) If true, the rule will fail if the pattern matches.
	// If true, the rule will fail if the pattern matches.
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// (String) The operator to use for matching. Can be one of: starts_with, ends_with, contains, regex.
	// The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// (String) The pattern to match with.
	// The pattern to match with.
	Pattern *string `json:"pattern,omitempty" tf:"pattern,omitempty"`
}

type TagNamePatternObservation struct {

	// (String) How this rule will appear to users.
	// How this rule will appear to users.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Boolean) If true, the rule will fail if the pattern matches.
	// If true, the rule will fail if the pattern matches.
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// (String) The operator to use for matching. Can be one of: starts_with, ends_with, contains, regex.
	// The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// (String) The pattern to match with.
	// The pattern to match with.
	Pattern *string `json:"pattern,omitempty" tf:"pattern,omitempty"`
}

type TagNamePatternParameters struct {

	// (String) How this rule will appear to users.
	// How this rule will appear to users.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// (Boolean) If true, the rule will fail if the pattern matches.
	// If true, the rule will fail if the pattern matches.
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// (String) The operator to use for matching. Can be one of: starts_with, ends_with, contains, regex.
	// The operator to use for matching. Can be one of: `starts_with`, `ends_with`, `contains`, `regex`.
	// +kubebuilder:validation:Optional
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// (String) The pattern to match with.
	// The pattern to match with.
	// +kubebuilder:validation:Optional
	Pattern *string `json:"pattern" tf:"pattern,omitempty"`
}

// RepositoryRulesetSpec defines the desired state of RepositoryRuleset
type RepositoryRulesetSpec struct {
	v2.ManagedResourceSpec `json:",inline"`
	ForProvider            RepositoryRulesetParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider RepositoryRulesetInitParameters `json:"initProvider,omitempty"`
}

// RepositoryRulesetStatus defines the observed state of RepositoryRuleset.
type RepositoryRulesetStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        RepositoryRulesetObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// RepositoryRuleset is the Schema for the RepositoryRulesets API. Creates a GitHub repository ruleset.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Namespaced,categories={crossplane,managed,github}
type RepositoryRuleset struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.enforcement) || (has(self.initProvider) && has(self.initProvider.enforcement))",message="spec.forProvider.enforcement is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.rules) || (has(self.initProvider) && has(self.initProvider.rules))",message="spec.forProvider.rules is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.target) || (has(self.initProvider) && has(self.initProvider.target))",message="spec.forProvider.target is a required parameter"
	Spec   RepositoryRulesetSpec   `json:"spec"`
	Status RepositoryRulesetStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// RepositoryRulesetList contains a list of RepositoryRulesets
type RepositoryRulesetList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []RepositoryRuleset `json:"items"`
}

// Repository type metadata.
var (
	RepositoryRuleset_Kind             = "RepositoryRuleset"
	RepositoryRuleset_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: RepositoryRuleset_Kind}.String()
	RepositoryRuleset_KindAPIVersion   = RepositoryRuleset_Kind + "." + CRDGroupVersion.String()
	RepositoryRuleset_GroupVersionKind = CRDGroupVersion.WithKind(RepositoryRuleset_Kind)
)

func init() {
	SchemeBuilder.Register(&RepositoryRuleset{}, &RepositoryRulesetList{})
}
